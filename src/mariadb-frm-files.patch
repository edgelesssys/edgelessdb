diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index 1936544e22c..ee105e0d995 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -52,6 +52,8 @@ ENDIF()
 INCLUDE_DIRECTORIES(
 ${CMAKE_SOURCE_DIR}/include
 ${CMAKE_SOURCE_DIR}/sql
+${CMAKE_SOURCE_DIR}/storage
+${CMAKE_SOURCE_DIR}/storage/rocksdb/rocksdb/include
 ${PCRE_INCLUDES}
 ${ZLIB_INCLUDE_DIR}
 ${SSL_INCLUDE_DIRS}
diff --git a/sql/datadict.cc b/sql/datadict.cc
index e09eee98565..146393d9090 100644
--- a/sql/datadict.cc
+++ b/sql/datadict.cc
@@ -20,25 +20,12 @@
 #include "sql_table.h"
 #include "ha_sequence.h"
 
-static int read_string(File file, uchar**to, size_t length)
-{
-  DBUG_ENTER("read_string");
-
-  /* This can't use MY_THREAD_SPECIFIC as it's used on server start */
-  if (!(*to= (uchar*) my_malloc(PSI_INSTRUMENT_ME, length+1,MYF(MY_WME))) ||
-      mysql_file_read(file, *to, length, MYF(MY_NABP)))
-  {
-     my_free(*to);
-    *to= 0;
-    DBUG_RETURN(1);
-  }
-  *((char*) *to+length)= '\0'; // C-style safety
-  DBUG_RETURN (0);
-}
-
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
 
 /**
   Check type of .frm if we are not going to parse it.
+  EDB: Read frm files from rocksdb.
 
   @param[in]  thd               The current session.
   @param[in]  path              path to FRM file.
@@ -57,15 +44,13 @@ static int read_string(File file, uchar**to, size_t length)
 
 Table_type dd_frm_type(THD *thd, char *path, LEX_CSTRING *engine_name)
 {
-  File file;
-  uchar header[40];     //"TYPE=VIEW\n" it is 10 characters
-  size_t error;
+  uchar *frm_image= nullptr, *header;
+  size_t frm_length;
   Table_type type= TABLE_TYPE_UNKNOWN;
   uchar dbt;
   DBUG_ENTER("dd_frm_type");
 
-  file= mysql_file_open(key_file_frm, path, O_RDONLY | O_SHARE, MYF(0));
-  if (file < 0)
+  if (!myrocks::rocksdb_frm_exists(path))
     DBUG_RETURN(TABLE_TYPE_UNKNOWN);
 
   /*
@@ -84,9 +69,11 @@ Table_type dd_frm_type(THD *thd, char *path, LEX_CSTRING *engine_name)
     ((char*) (engine_name->str))[0]= 0;
   }
 
-  if (unlikely((error= mysql_file_read(file, (uchar*) header, sizeof(header), MYF(MY_NABP)))))
+  if (myrocks::rocksdb_frm_read(path, &frm_image, &frm_length))
     goto err;
 
+  header = frm_image;
+
   if (unlikely((!strncmp((char*) header, "TYPE=VIEW\n", 10))))
   {
     type= TABLE_TYPE_VIEW;
@@ -121,18 +108,8 @@ Table_type dd_frm_type(THD *thd, char *path, LEX_CSTRING *engine_name)
 
   /* read the true engine name */
   {
-    MY_STAT state;  
-    uchar *frm_image= 0;
     uint n_length;
 
-    if (mysql_file_fstat(file, &state, MYF(MY_WME)))
-      goto err;
-
-    if (mysql_file_seek(file, 0, SEEK_SET, MYF(MY_WME)))
-      goto err;
-
-    if (read_string(file, &frm_image, (size_t)state.st_size))
-      goto err;
 
     if ((n_length= uint4korr(frm_image+55)))
     {
@@ -159,13 +136,11 @@ Table_type dd_frm_type(THD *thd, char *path, LEX_CSTRING *engine_name)
         }
       }
     }
-
-    my_free(frm_image);
   }
 
   /* Probably a table. */
 err:
-  mysql_file_close(file, MYF(MY_WME));
+  my_free(frm_image);
   DBUG_RETURN(type);
 }
 
diff --git a/sql/handler.cc b/sql/handler.cc
index c6031e252a6..d28dced58cf 100644
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -65,6 +65,9 @@
 #include "wsrep_var.h"            /* wsrep_hton_check() */
 #endif /* WITH_WSREP */
 
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
+
 /**
   @def MYSQL_TABLE_LOCK_WAIT
   Instrumentation helper for table io_waits.
@@ -5853,7 +5856,9 @@ bool ha_table_exists(THD *thd, const LEX_CSTRING *db,
                                          db->str, table_name->str, "", 0);
   st_discover_existence_args args= {path, path_len, db->str, table_name->str, 0, true};
 
-  if (file_ext_exists(path, path_len, reg_ext))
+  // EDB: Check if .frm exists in rocksdb.
+  strmake(path + path_len, reg_ext, FN_REFLEN - path_len);
+  if (myrocks::rocksdb_frm_exists(path))
   {
     bool exists= true;
     if (hton)
diff --git a/sql/parse_file.cc b/sql/parse_file.cc
index 59b4027a352..b00dcfacbd7 100644
--- a/sql/parse_file.cc
+++ b/sql/parse_file.cc
@@ -28,12 +28,16 @@
 #include <m_ctype.h>
 #include <my_dir.h>
 
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
+
 /* from sql_db.cc */
 extern long mysql_rm_arc_files(THD *thd, MY_DIR *dirp, const char *org_path);
 
 
 /**
   Write string with escaping.
+  EDB: Return as std::string instead of writing to .frm file
 
   @param file	  IO_CACHE for record
   @param val_s	  string for writing
@@ -45,7 +49,7 @@ extern long mysql_rm_arc_files(THD *thd, MY_DIR *dirp, const char *org_path);
 */
 
 static my_bool
-write_escaped_string(IO_CACHE *file, LEX_STRING *val_s)
+write_escaped_string(std::string &file, LEX_STRING *val_s)
 {
   char *eos= val_s->str + val_s->length;
   char *ptr= val_s->str;
@@ -58,28 +62,22 @@ write_escaped_string(IO_CACHE *file, LEX_STRING *val_s)
     */
     switch(*ptr) {
     case '\\': // escape character
-      if (my_b_write(file, (const uchar *)STRING_WITH_LEN("\\\\")))
-	return TRUE;
+      file += "\\\\";
       break;
     case '\n': // parameter value delimiter
-      if (my_b_write(file, (const uchar *)STRING_WITH_LEN("\\n")))
-	return TRUE;
+      file += "\\n";
       break;
     case '\0': // problem for some string processing utilities
-      if (my_b_write(file, (const uchar *)STRING_WITH_LEN("\\0")))
-	return TRUE;
+      file += "\\0";
       break;
     case 26: // problem for windows utilities (Ctrl-Z)
-      if (my_b_write(file, (const uchar *)STRING_WITH_LEN("\\z")))
-	return TRUE;
+      file += "\\z";
       break;
     case '\'': // list of string delimiter
-      if (my_b_write(file, (const uchar *)STRING_WITH_LEN("\\\'")))
-	return TRUE;
+      file += "\\\'";
       break;
     default:
-      if (my_b_write(file, (const uchar *)ptr, 1))
-	return TRUE;
+      file += ptr[0];
     }
   }
   return FALSE;
@@ -122,6 +120,7 @@ static ulonglong view_algo_from_frm(ulonglong val)
 
 /**
   Write parameter value to IO_CACHE.
+  EDG: Return as std::string instead of writing to .frm file
 
   @param file          pointer to IO_CACHE structure for writing
   @param base          pointer to data structure
@@ -135,7 +134,7 @@ static ulonglong view_algo_from_frm(ulonglong val)
 
 
 static my_bool
-write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
+write_parameter(std::string &file, const uchar* base, File_option *parameter)
 {
   char num_buf[20];			// buffer for numeric operations
   // string for numeric operations
@@ -146,8 +145,7 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
   case FILE_OPTIONS_STRING:
   {
     LEX_STRING *val_s= (LEX_STRING *)(base + parameter->offset);
-    if (my_b_write(file, (const uchar *)val_s->str, val_s->length))
-      DBUG_RETURN(TRUE);
+    file.append(val_s->str, val_s->length);
     break;
   }
   case FILE_OPTIONS_ESTRING:
@@ -165,8 +163,7 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
       val= view_algo_to_frm(val);
 
     num.set(val, &my_charset_bin);
-    if (my_b_write(file, (const uchar *)num.ptr(), num.length()))
-      DBUG_RETURN(TRUE);
+    file.append(num.ptr(), num.length());
     break;
   }
   case FILE_OPTIONS_TIMESTAMP:
@@ -178,9 +175,7 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
     get_date(val_s->str, GETDATE_DATE_TIME|GETDATE_GMT|GETDATE_FIXEDLENGTH,
 	     tm);
     val_s->length= PARSE_FILE_TIMESTAMPLENGTH;
-    if (my_b_write(file, (const uchar *)val_s->str,
-                    PARSE_FILE_TIMESTAMPLENGTH))
-      DBUG_RETURN(TRUE);
+    file.append(val_s->str, PARSE_FILE_TIMESTAMPLENGTH);
     break;
   }
   case FILE_OPTIONS_STRLIST:
@@ -192,13 +187,12 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
     while ((str= it++))
     {
       // We need ' ' after string to detect list continuation
-      if ((!first && my_b_write(file, (const uchar *)STRING_WITH_LEN(" "))) ||
-	  my_b_write(file, (const uchar *)STRING_WITH_LEN("\'")) ||
-          write_escaped_string(file, str) ||
-	  my_b_write(file, (const uchar *)STRING_WITH_LEN("\'")))
-      {
-	DBUG_RETURN(TRUE);
+      if (!first) {
+        file += ' ';
       }
+      file += '\'';
+      write_escaped_string(file, str);
+      file += '\'';
       first= 0;
     }
     break;
@@ -213,11 +207,10 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
     {
       num.set(*val, &my_charset_bin);
       // We need ' ' after string to detect list continuation
-      if ((!first && my_b_write(file, (const uchar *)STRING_WITH_LEN(" "))) ||
-          my_b_write(file, (const uchar *)num.ptr(), num.length()))
-      {
-        DBUG_RETURN(TRUE);
+      if (!first) {
+        file += ' ';
       }
+      file.append(num.ptr(), num.length());
       first= 0;
     }
     break;
@@ -231,6 +224,7 @@ write_parameter(IO_CACHE *file, const uchar* base, File_option *parameter)
 
 /**
   Write new .frm.
+  EDB: Store in rocksdb instead of file on disk.
 
   @param dir           directory where put .frm
   @param file_name     .frm file name
@@ -252,10 +246,7 @@ sql_create_definition_file(const LEX_CSTRING *dir,
 			   const LEX_CSTRING *type,
 			   uchar* base, File_option *parameters)
 {
-  File handler;
-  IO_CACHE file;
   char path[FN_REFLEN+1];	// +1 to put temporary file name for sure
-  size_t path_end;
   File_option *param;
   DBUG_ENTER("sql_create_definition_file");
   DBUG_PRINT("enter", ("Dir: %s, file: %s, base %p",
@@ -265,7 +256,6 @@ sql_create_definition_file(const LEX_CSTRING *dir,
   if (dir)
   {
     fn_format(path, file_name->str, dir->str, "", MY_UNPACK_FILENAME);
-    path_end= strlen(path);
   }
   else
   {
@@ -274,70 +264,25 @@ sql_create_definition_file(const LEX_CSTRING *dir,
       including dir name, file name itself, and an extension,
       and with unpack_filename() executed over it.
     */    
-    path_end= strxnmov(path, sizeof(path) - 1, file_name->str, NullS) - path;
+    strxnmov(path, sizeof(path) - 1, file_name->str, NullS);
   }
 
-  // temporary file name
-  path[path_end]='~';
-  path[path_end+1]= '\0';
-  if ((handler= mysql_file_create(key_file_fileparser,
-                                  path, CREATE_MODE, O_RDWR | O_TRUNC,
-                                  MYF(MY_WME))) < 0)
-  {
-    DBUG_RETURN(TRUE);
-  }
-
-  if (init_io_cache(&file, handler, 0, WRITE_CACHE, 0L, 0, MYF(MY_WME)))
-    goto err_w_file;
-
   // write header (file signature)
-  if (my_b_write(&file, (const uchar *)STRING_WITH_LEN("TYPE=")) ||
-      my_b_write(&file, (const uchar *)type->str, type->length) ||
-      my_b_write(&file, (const uchar *)STRING_WITH_LEN("\n")))
-    goto err_w_cache;
+  std::string frm = "TYPE=";
+  frm.append(type->str, type->length);
+  frm += '\n';
 
-  // write parameters to temporary file
+  // add parameters to frm
   for (param= parameters; param->name.str; param++)
   {
-    if (my_b_write(&file, (const uchar *)param->name.str,
-                    param->name.length) ||
-	my_b_write(&file, (const uchar *)STRING_WITH_LEN("=")) ||
-	write_parameter(&file, base, param) ||
-	my_b_write(&file, (const uchar *)STRING_WITH_LEN("\n")))
-      goto err_w_cache;
+    frm.append(param->name.str, param->name.length);
+    frm += '=';
+    write_parameter(frm, base, param);
+    frm += '\n';
   }
 
-  if (end_io_cache(&file))
-    goto err_w_file;
-
-  if (opt_sync_frm) {
-    if (mysql_file_sync(handler, MYF(MY_WME)))
-      goto err_w_file;
-  }
-
-  if (mysql_file_close(handler, MYF(MY_WME)))
-  {
-    DBUG_RETURN(TRUE);
-  }
-
-  path[path_end]='\0';
-
-  {
-    // rename temporary file
-    char path_to[FN_REFLEN];
-    memcpy(path_to, path, path_end+1);
-    path[path_end]='~';
-    if (mysql_file_rename(key_file_fileparser, path, path_to, MYF(MY_WME)))
-    {
-      DBUG_RETURN(TRUE);
-    }
-  }
-  DBUG_RETURN(FALSE);
-err_w_cache:
-  end_io_cache(&file);
-err_w_file:
-  mysql_file_close(handler, MYF(MY_WME));
-  DBUG_RETURN(TRUE);
+  const bool error = myrocks::rocksdb_frm_write(path, reinterpret_cast<const uchar*>(frm.c_str()), frm.size());
+  DBUG_RETURN(error);
 }
 
 /**
@@ -365,8 +310,20 @@ my_bool rename_in_schema_file(THD *thd,
   build_table_filename(new_path, sizeof(new_path) - 1,
                        new_db, new_name, reg_ext, 0);
 
-  if (mysql_file_rename(key_file_frm, old_path, new_path, MYF(MY_WME)))
+  // EDB: Rename in rocksdb instead of files on disk.
+  uchar *frm;
+  size_t frm_length;
+  if (myrocks::rocksdb_frm_read(old_path, &frm, &frm_length)) {
+    return 1;
+  }
+  const bool error= myrocks::rocksdb_frm_write(new_path, frm, frm_length);
+  my_free(frm);
+  if (error) {
+    return 1;
+  }
+  if (myrocks::rocksdb_frm_delete(old_path)) {
     return 1;
+  }
 
   /* check if arc_dir exists: disabled unused feature (see bug #17823). */
   build_table_filename(arc_path, sizeof(arc_path) - 1, schema, "arc", "", 0);
diff --git a/sql/rpl_rli.cc b/sql/rpl_rli.cc
index 4c04382a5dc..56499f5d5eb 100644
--- a/sql/rpl_rli.cc
+++ b/sql/rpl_rli.cc
@@ -34,6 +34,9 @@
 #include "lock.h"
 #include "sql_table.h"
 
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
+
 static int count_relay_log_space(Relay_log_info* rli);
 bool xa_trans_force_rollback(THD *thd);
 /**
@@ -1687,35 +1690,32 @@ scan_one_gtid_slave_pos_table(THD *thd, HASH *hash, DYNAMIC_ARRAY *array,
   Look for all tables mysql.gtid_slave_pos*. Read all rows from each such
   table found into ARRAY. For each domain id, put the row with highest sub_id
   into HASH.
+  EDB: Check for .frm files in rocksdb instead of disk.
 */
 static int
 scan_all_gtid_slave_pos_table(THD *thd, int (*cb)(THD *, LEX_CSTRING *, void *),
                               void *cb_data)
 {
   char path[FN_REFLEN];
-  MY_DIR *dirp;
 
   thd->reset_for_next_command();
   if (lock_schema_name(thd, MYSQL_SCHEMA_NAME.str))
     return 1;
 
   build_table_filename(path, sizeof(path) - 1, MYSQL_SCHEMA_NAME.str, "", "", 0);
-  if (!(dirp= my_dir(path, MYF(MY_DONT_SORT))))
-  {
-    my_error(ER_FILE_NOT_FOUND, MYF(0), path, my_errno);
-    close_thread_tables(thd);
-    thd->release_transactional_locks();
-    return 1;
-  }
-  else
   {
     size_t i;
-    Dynamic_array<LEX_CSTRING*> files(dirp->number_of_files);
+    Dynamic_array<LEX_CSTRING*> files(1);
     Discovered_table_list tl(thd, &files);
-    int err;
+    int err= 0;
+
+    for (const auto &tablename : myrocks::rocksdb_frm_discover(path)) {
+      if (tl.add_file(tablename.c_str())) {
+        err= 1;
+        break;
+      }
+    }
 
-    err= ha_discover_table_names(thd, &MYSQL_SCHEMA_NAME, dirp, &tl, false);
-    my_dirend(dirp);
     close_thread_tables(thd);
     thd->release_transactional_locks();
     if (err)
diff --git a/sql/sql_table.cc b/sql/sql_table.cc
index 8fd9265cf19..ebae46ab184 100644
--- a/sql/sql_table.cc
+++ b/sql/sql_table.cc
@@ -58,6 +58,9 @@
 #include "sql_insert.h"                        // binlog_drop_table
 #include <algorithm>
 
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
+
 #ifdef __WIN__
 #include <io.h>
 #endif
@@ -1796,6 +1799,8 @@ uint build_table_shadow_filename(char *buff, size_t bufflen,
     A support method that creates a new frm file and in this process it
     regenerates the partition data. It works fine also for non-partitioned
     tables since it only handles partitioned data if it exists.
+
+  EDB: Write to rocksdb instead of disk.
 */
 
 bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
@@ -1809,6 +1814,8 @@ bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
   char path[FN_REFLEN+1];
   char shadow_path[FN_REFLEN+1];
   char shadow_frm_name[FN_REFLEN+1];
+  uchar *shadow= nullptr;
+  size_t shadow_length;
   char frm_name[FN_REFLEN+1];
 #ifdef WITH_PARTITION_STORAGE_ENGINE
   char *part_syntax_buf;
@@ -1857,8 +1864,7 @@ bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
       goto end;
     }
 
-    int error= writefile(shadow_frm_name, lpt->db.str, lpt->table_name.str,
-                         lpt->create_info->tmp_table(), frm.str, frm.length);
+    int error= myrocks::rocksdb_frm_write(shadow_frm_name, frm.str, frm.length);
     my_free(const_cast<uchar*>(frm.str));
 
     if (unlikely(error) ||
@@ -1866,7 +1872,7 @@ bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
                  ha_create_partitioning_metadata(shadow_path,
                                                  NULL, CHF_CREATE_FLAG)))
     {
-      mysql_file_delete(key_file_frm, shadow_frm_name, MYF(0));
+      myrocks::rocksdb_frm_delete(shadow_frm_name);
       error= 1;
       goto end;
     }
@@ -1892,19 +1898,18 @@ bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
       completing this we write a new phase to the log entry that will
       deactivate it.
     */
-    if (mysql_file_delete(key_file_frm, frm_name, MYF(MY_WME)) ||
+    if (myrocks::rocksdb_frm_read(shadow_frm_name, &shadow, &shadow_length) ||
+        myrocks::rocksdb_frm_delete(shadow_frm_name) ||
 #ifdef WITH_PARTITION_STORAGE_ENGINE
         lpt->table->file->ha_create_partitioning_metadata(path, shadow_path,
                                                           CHF_DELETE_FLAG) ||
         deactivate_ddl_log_entry(part_info->frm_log_entry->entry_pos) ||
         (sync_ddl_log(), FALSE) ||
-        mysql_file_rename(key_file_frm,
-                          shadow_frm_name, frm_name, MYF(MY_WME)) ||
+        myrocks::rocksdb_frm_write(frm_name, shadow, shadow_length) ||
         lpt->table->file->ha_create_partitioning_metadata(path, shadow_path,
                                                           CHF_RENAME_FLAG))
 #else
-        mysql_file_rename(key_file_frm,
-                          shadow_frm_name, frm_name, MYF(MY_WME)))
+        myrocks::rocksdb_frm_write(frm_name, shadow, shadow_length))
 #endif
     {
       error= 1;
@@ -1952,6 +1957,7 @@ bool mysql_write_frm(ALTER_PARTITION_PARAM_TYPE *lpt, uint flags)
   }
 
 end:
+  my_free(shadow);
   DBUG_RETURN(error);
 }
 
diff --git a/sql/table.cc b/sql/table.cc
index 271460bad52..9f9e72c5d5f 100644
--- a/sql/table.cc
+++ b/sql/table.cc
@@ -46,6 +46,9 @@
 #include "sql_show.h"
 #include "opt_trace.h"
 
+/* EDB: rocksdb header */
+#include "rocksdb/ha_rocksdb.h"
+
 /* For MySQL 5.7 virtual fields */
 #define MYSQL57_GENERATED_FIELD 128
 #define MYSQL57_GCOL_HEADER_SIZE 4
@@ -613,11 +616,11 @@ inline bool is_system_table_name(const char *name, size_t length)
 enum open_frm_error open_table_def(THD *thd, TABLE_SHARE *share, uint flags)
 {
   bool error_given= false;
-  File file;
-  uchar *buf;
-  uchar head[FRM_HEADER_SIZE];
+  File file= 0;
+  uchar *buf= nullptr;
+  uchar *head;
   char	path[FN_REFLEN];
-  size_t frmlen, read_length;
+  size_t frmlen;
   uint length;
   DBUG_ENTER("open_table_def");
   DBUG_PRINT("enter", ("table: '%s'.'%s'  path: '%s'", share->db.str,
@@ -629,17 +632,28 @@ enum open_frm_error open_table_def(THD *thd, TABLE_SHARE *share, uint flags)
                  path);
   if (flags & GTS_FORCE_DISCOVERY)
   {
-    const char *path2= share->normalized_path.str;
+    char path2[FN_REFLEN];
     DBUG_ASSERT(flags & GTS_TABLE);
     DBUG_ASSERT(flags & GTS_USE_DISCOVERY);
     /* Delete .frm and .par files */
-    mysql_file_delete_with_symlink(key_file_frm, path2, reg_ext, MYF(0));
-    mysql_file_delete_with_symlink(key_file_partition_ddl_log, path2, PAR_EXT,
-                                   MYF(0));
+    const char *fullname= fn_format(path2, share->normalized_path.str, "", reg_ext, MY_UNPACK_FILENAME | MY_APPEND_EXT);
+    if (myrocks::rocksdb_frm_delete(fullname)) {
+      goto err;
+    }
+    fullname= fn_format(path2, share->normalized_path.str, "", PAR_EXT, MY_UNPACK_FILENAME | MY_APPEND_EXT);
+    if (myrocks::rocksdb_frm_delete(fullname)) {
+      goto err;
+    }
     file= -1;
   }
   else
-    file= mysql_file_open(key_file_frm, path, O_RDONLY | O_SHARE, MYF(0));
+  {
+    if(myrocks::rocksdb_frm_read(path, &buf, &frmlen)) {
+      file= -1;
+    } else {
+      head = buf;
+    }
+  }
 
   if (file < 0)
   {
@@ -648,13 +662,6 @@ enum open_frm_error open_table_def(THD *thd, TABLE_SHARE *share, uint flags)
       ha_discover_table(thd, share);
       error_given= true;
     }
-    goto err_not_open;
-  }
-
-  if (mysql_file_read(file, head, sizeof(head), MYF(MY_NABP)))
-  {
-    share->error = my_errno == HA_ERR_FILE_TOO_SHORT
-                      ? OPEN_FRM_CORRUPTED : OPEN_FRM_READ_ERROR;
     goto err;
   }
 
@@ -690,26 +697,6 @@ enum open_frm_error open_table_def(THD *thd, TABLE_SHARE *share, uint flags)
     goto err;
   }
 
-  frmlen= uint4korr(head+10);
-  set_if_smaller(frmlen, FRM_MAX_SIZE); // safety
-
-  if (!(buf= (uchar*)my_malloc(PSI_INSTRUMENT_ME, frmlen,
-                               MYF(MY_THREAD_SPECIFIC|MY_WME))))
-    goto err;
-
-  memcpy(buf, head, sizeof(head));
-
-  read_length= mysql_file_read(file, buf + sizeof(head),
-                               frmlen - sizeof(head), MYF(MY_WME));
-  if (read_length == 0 || read_length == (size_t)-1)
-  {
-    share->error = OPEN_FRM_READ_ERROR;
-    my_free(buf);
-    goto err;
-  }
-  mysql_file_close(file, MYF(MY_WME));
-
-  frmlen= read_length + sizeof(head);
 
   share->init_from_binary_frm_image(thd, false, buf, frmlen);
   /*
@@ -717,14 +704,10 @@ enum open_frm_error open_table_def(THD *thd, TABLE_SHARE *share, uint flags)
     init_from_binary_frm_image would call my_error() itself.
   */
   error_given= true;
-  my_free(buf);
-
-  goto err_not_open;
 
 err:
-  mysql_file_close(file, MYF(MY_WME));
+  my_free(buf);
 
-err_not_open:
   /* Mark that table was created earlier and thus should have been logged */
   share->table_creation_was_logged= 1;
 
@@ -3445,8 +3428,7 @@ bool TABLE_SHARE::write_frm_image(const uchar *frm, size_t len)
   char file_name[FN_REFLEN+1];
   strxnmov(file_name, sizeof(file_name)-1, normalized_path.str, reg_ext,
            NullS);
-  return writefile(file_name, db.str, table_name.str, false,
-                   frm, len);
+  return myrocks::rocksdb_frm_write(file_name, frm, len);
 }
 
 bool TABLE_SHARE::write_par_image(const uchar *par, size_t len)
@@ -3454,7 +3436,7 @@ bool TABLE_SHARE::write_par_image(const uchar *par, size_t len)
   char file_name[FN_REFLEN+1];
   strxnmov(file_name, sizeof(file_name)-1, normalized_path.str, PAR_EXT,
            NullS);
-  return writefile(file_name, db.str, table_name.str, false, par, len);
+  return myrocks::rocksdb_frm_write(file_name, par, len);
 }
 
 
@@ -3474,7 +3456,7 @@ bool TABLE_SHARE::read_frm_image(const uchar **frm, size_t *len)
     frm_image= 0;
     return 0;
   }
-  return readfrm(normalized_path.str, frm, len);
+  return myrocks::rocksdb_frm_read(normalized_path.str, const_cast<uchar**>(frm), len);
 }
 
 
diff --git a/storage/rocksdb/ha_rocksdb.cc b/storage/rocksdb/ha_rocksdb.cc
index f89601b1789..c053be8b3c1 100644
--- a/storage/rocksdb/ha_rocksdb.cc
+++ b/storage/rocksdb/ha_rocksdb.cc
@@ -13869,6 +13869,152 @@ bool ha_rocksdb::can_use_bloom_filter(THD *thd, const Rdb_key_def &kd,
   return can_use;
 }
 
+/*
+ * EDB: Helper functions to store/manage .frm files in rocksdb instead of filesystem.
+ *
+ */
+
+const std::string EDG_FRM_CF_NAME("edg_frm_cf");
+
+/**
+ * EDB: Checks if a frm file exists in rocksdb
+ *
+ * @details Checks if a MariaDB table definitions as .frm file exists in rocksdb
+ *
+ * @param frm_path  Path of the frm file. Used as key in rocksdb.
+*/
+bool rocksdb_frm_exists(const char *frm_path) {
+  DBUG_PRINT("rocksdb_frm_exists",("path: %s", frm_path));
+  if (!rdb) {
+    return false;
+  }
+  const auto cf_handle = cf_manager.get_or_create_cf(rdb, EDG_FRM_CF_NAME);
+  std::string value;
+  const auto status = rdb->Get({}, cf_handle, frm_path, &value);
+  if (!status.ok()) {
+    DBUG_PRINT("rocksdb::DB->Get", ("status: %s", status.ToString()));
+    return false;
+  }
+  return true;
+}
+
+/**
+ * EDB: Store frm file in rocksdb
+ *
+ * @details Store MariaDB table definitions as .frm binary image in rocksdb
+ *
+ * @param frm_path  Path of the frm file. Used as key in rocksdb.
+ * @param frm       Binary frm image.
+ * @param len       Size of frm image.
+*/
+bool rocksdb_frm_write(char *frm_path, const uchar *frm, size_t len) {
+  DBUG_PRINT("rocksdb_frm_write",("path: %s", frm_path));
+  if (!rdb) {
+     return true;
+  }
+  const auto cf_handle = cf_manager.get_or_create_cf(rdb, EDG_FRM_CF_NAME);
+  const auto status = rdb->Put({}, cf_handle, frm_path, {reinterpret_cast<const char*>(frm), len});
+  if (!status.ok()) {
+    DBUG_PRINT("rocksdb::DB->Put", ("status: %s", status.ToString()));
+    return true;
+  }
+  return false;
+}
+
+
+/**
+ * EDB: Read frm file from rocksdb
+ *
+ * @details Read MariaDB table definitions as .frm file from rocksdb
+ *
+ * @param frm_path  Path of the frm file. Used as key in rocksdb.
+ * @param frm       Pointer to return binary frm image.
+ * @param len       Pointer to return size of frm image.
+*/
+bool rocksdb_frm_read(const char *frm_path, uchar **frm, size_t *len) {
+  DBUG_PRINT("rocksdb_frm_read",("path: %s", frm_path));
+  if (!rdb) {
+     return true;
+  }
+  const auto cf_handle = cf_manager.get_or_create_cf(rdb, EDG_FRM_CF_NAME);
+  std::string value;
+  const auto status = rdb->Get({}, cf_handle, frm_path, &value);
+  if (!status.ok()) {
+    DBUG_PRINT("rocksdb::DB->Get", ("status: %s", status.ToString()));
+    return true;
+  }
+
+  /* rocksdb_frm_read is called before mysqld is done initializing, hence, we can't use MY_THREAD_SPECIFIC */
+  const auto buf= static_cast<uchar*>(my_malloc(PSI_INSTRUMENT_ME, value.size()+1, MYF(MY_WME)));
+  if (!buf) {
+    return true;
+  }
+
+  memcpy(buf, value.c_str(), value.size());
+  buf[value.size()]= 0;
+  *frm= buf;
+  *len= value.size();
+  return false;
+}
+
+/**
+ * EDB: Delete frm file from rocksdb
+ *
+ * @details Delete MariaDB table definitions from rocksdb
+ *
+ * @param frm_path  Path of the frm file. Used as key in rocksdb.
+*/
+bool rocksdb_frm_delete(const char *frm_path) {
+  DBUG_PRINT("rocksdb_frm_delete",("path: %s", frm_path));
+  if (!rdb) {
+     return true;
+  }
+  const auto cf_handle = cf_manager.get_or_create_cf(rdb, EDG_FRM_CF_NAME);
+  const auto status = rdb->Delete({}, cf_handle, frm_path);
+  if (!status.ok()) {
+    DBUG_PRINT("rocksdb::DB->Delete", ("status: %s", status.ToString()));
+    return true;
+  }
+  return false;
+}
+
+
+/**
+ * EDB: Discover table names based on frm files in rocksdb
+ *
+ * @details Discover MariaDB table definitions as .frm files in rocksdb
+ *
+ * @param frm_path  Prefix ofthe frm files. Used as prefix in rocksdb.
+ * @return Vector of table names.
+*/
+std::vector<std::string> rocksdb_frm_discover(const char *frm_path) {
+  DBUG_PRINT("rocksdb_frm_discover",("path: %s", frm_path));
+  if (!rdb) {
+    return {};
+  }
+  const auto cf_handle = cf_manager.get_or_create_cf(rdb, EDG_FRM_CF_NAME);
+  const std::unique_ptr<rocksdb::Iterator> iter(rdb->NewIterator({}, cf_handle));
+  if (!iter) {
+    return {};
+  }
+
+  std::vector<std::string> result;
+  for (iter->Seek(frm_path); iter->Valid(); iter->Next()) {
+    const std::string key = iter->key().ToString();
+    /* Only add the current key if it is a prefix */
+    if (key.rfind(frm_path, 0) == 0) {
+      // get table name from frm file path
+      const size_t ext_idx = key.rfind(FN_EXTCHAR);
+      const size_t base_idx = key.rfind(FN_LIBCHAR);
+      assert(0 < base_idx && base_idx < ext_idx && ext_idx < key.size());
+      result.push_back(key.substr(base_idx + 1, ext_idx - base_idx - 1));
+    }
+  }
+  return result;
+}
+
+/* EDB: End of helper functions */
+
 /* For modules that need access to the global data structures */
 rocksdb::TransactionDB *rdb_get_rocksdb_db() { return rdb; }
 
diff --git a/storage/rocksdb/ha_rocksdb.h b/storage/rocksdb/ha_rocksdb.h
index 05b5341bfb1..4efb836cced 100644
--- a/storage/rocksdb/ha_rocksdb.h
+++ b/storage/rocksdb/ha_rocksdb.h
@@ -1065,5 +1065,15 @@ extern bool prevent_myrocks_loading;
 
 void sql_print_verbose_info(const char *format, ...);
 
+/*
+ * EDB: Storing/managing frm files in rocksdb.
+ * Helper functions to handle storing/managing frm files in rocksdb instead of the disk.
+ */
+bool rocksdb_frm_exists(const char *frm_path);
+bool rocksdb_frm_write(char *frm_path, const uchar *frm, size_t len);
+bool rocksdb_frm_read(const char *frm_path, uchar **frm, size_t *len);
+bool rocksdb_frm_delete(const char *frm_path);
+std::vector<std::string> rocksdb_frm_discover(const char *frm_path);
+
 }  // namespace myrocks
 
diff --git a/storage/rocksdb/rdb_datadic.cc b/storage/rocksdb/rdb_datadic.cc
index 5f46fd8acad..72cb787fb73 100644
--- a/storage/rocksdb/rdb_datadic.cc
+++ b/storage/rocksdb/rdb_datadic.cc
@@ -3834,31 +3834,16 @@ bool Rdb_validate_tbls::check_frm_file(const std::string &fullpath,
 }
 
 /* Scan the database subdirectory for .frm files */
+/* EDB: Scan in rocksdb instead of disk. */
 bool Rdb_validate_tbls::scan_for_frms(const std::string &datadir,
                                       const std::string &dbname,
                                       bool *has_errors) {
   bool result = true;
-  std::string fullpath = datadir + dbname;
-  struct st_my_dir *dir_info = my_dir(fullpath.c_str(), MYF(MY_DONT_SORT));
-
-  /* Access the directory */
-  if (dir_info == nullptr) {
-    // NO_LINT_DEBUG
-    sql_print_warning("RocksDB: Could not open database directory: %s",
-                      fullpath.c_str());
-    return false;
-  }
-
-  /* Scan through the files in the directory */
-  struct fileinfo *file_info = dir_info->dir_entry;
-  for (uint ii = 0; ii < dir_info->number_of_files; ii++, file_info++) {
-    /* Find .frm files that are not temp files (those that contain '#sql') */
-    const char *ext = strrchr(file_info->name, '.');
-    if (ext != nullptr && strstr(file_info->name, tmp_file_prefix) == nullptr &&
-        strcmp(ext, ".frm") == 0) {
-      std::string tablename =
-          std::string(file_info->name, ext - file_info->name);
+  /* EDB: Paths should be joined in a clean way. We need std::filesystem from C++17 or boost.*/
+  std::string fullpath = datadir + FN_LIBCHAR + dbname;
 
+  for (const auto &tablename : myrocks::rocksdb_frm_discover(fullpath.c_str())) {
+    {
       /* Check to see if the .frm file is from RocksDB */
       if (!check_frm_file(fullpath, dbname, tablename, has_errors)) {
         result = false;
@@ -3872,9 +3857,6 @@ bool Rdb_validate_tbls::scan_for_frms(const std::string &datadir,
     m_list.erase(dbname);
   }
 
-  /* Release the directory entry */
-  my_dirend(dir_info);
-
   return result;
 }
 
@@ -3987,7 +3969,8 @@ bool Rdb_ddl_manager::validate_auto_incr() {
 */
 bool Rdb_ddl_manager::validate_schemas(void) {
   bool has_errors = false;
-  const std::string datadir = std::string(mysql_real_data_home);
+  // EDB: Use relative mysql_data_home to match frm-paths in rocksdb.
+  const std::string datadir = std::string(mysql_data_home);
   Rdb_validate_tbls table_list;
 
   /* Get the list of tables from the database dictionary */
